

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>IImage &mdash; Arena 0.1.24.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Arena 0.1.24.0 documentation" href="index.html"/>
        <link rel="up" title="Arena C++" href="cpp_arena.html"/>
        <link rel="next" title="FeatureStream" href="cpp_arena_featurestream.html"/>
        <link rel="prev" title="InterfaceInfo" href="cpp_arena_interfaceinfo.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home">
          

          <!--
            
            <img src="_static/lucid-white.png" class="logo" />
          -->
          </a>

          
            
            
              <div class="version">
                0.1.24
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="welcome.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact_us.html">Contact Us</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_sdk_datasheet.html">Arena SDK Datasheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="arena_sdk_windows.html">Arena SDK for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="arena_sdk_linux.html">Arena SDK for Linux</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="sdk.html">Code Reference &amp; Samples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gentl.html">GenTL Features</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="cpp.html">Arena C++</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="cpp_arena.html">Arena C++</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_defs.html">Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_global.html">Global Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_isystem.html">ISystem</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_imagefactory.html">ImageFactory</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_ichunkdata.html">IChunkData</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_ibuffer.html">IBuffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_interfaceinfo.html">InterfaceInfo</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">IImage</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_featurestream.html">FeatureStream</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_idevice.html">IDevice</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_deviceinfo.html">DeviceInfo</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_einterfacetypeclass.html">EInterfaceTypeClass</a></li>
<li class="toctree-l4"><a class="reference internal" href="cpp_arena_eincmodeclass.html">EIncModeClass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cpp_genapi.html">GenApi C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpp_save.html">Save C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpp_examples.html">C++ Code Samples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="c.html">Arena C</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Arena</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="sdk.html">Code Reference &amp; Samples</a> &raquo;</li>
        
          <li><a href="cpp.html">Arena C++</a> &raquo;</li>
        
          <li><a href="cpp_arena.html">Arena C++</a> &raquo;</li>
        
      <li>IImage</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="iimage">
<h1>IImage<a class="headerlink" href="#iimage" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="id1">
<h2>IImage<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv3N5Arena6IImageE">
<span id="_CPPv2N5Arena6IImageE"></span><span id="Arena::IImage"></span><span class="target" id="class_arena_1_1_i_image"></span><em class="property">class </em><code class="descname">IImage</code> : <em class="property">public</em> Arena::<a class="reference internal" href="cpp_arena_ibuffer.html#_CPPv3N5Arena7IBufferE" title="Arena::IBuffer">IBuffer</a><a class="headerlink" href="#_CPPv3N5Arena6IImageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An interface to an image object</p>
<p>Images are the most common form of data retrieved from the stream engine. They are retrieved and requeued via devices (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) as well as created, copied, and converted via the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>).</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// retrieving an image after starting the stream</span>
<span class="c1">// requeuing it before stopping the stream</span>
<span class="p">{</span>
    <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">StartStream</span><span class="p">();</span>
    <span class="n">Arena</span><span class="o">::</span><span class="n">IImage</span><span class="o">*</span> <span class="n">pImage</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">GetImage</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">RequeueBuffer</span><span class="p">(</span><span class="n">pImage</span><span class="p">);</span>
    <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">StopStream</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p>Along with the functionality of its parent class (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer"><span class="std std-ref">Arena::IBuffer</span></a>), images provide access to additional information particular to images. This includes:<ul class="simple">
<li>size information (<a class="reference internal" href="#class_arena_1_1_i_image_1a3056d60ca22b209922bd6fdeb99e3f41"><span class="std std-ref">Arena::IImage::GetWidth</span></a>, <a class="reference internal" href="#class_arena_1_1_i_image_1aaf4a3ba162499e7d142f23f07f709b67"><span class="std std-ref">Arena::IImage::GetHeight</span></a></li>
<li>offsets (<a class="reference internal" href="#class_arena_1_1_i_image_1a31afe0e36757029b3e1e9756b5776e25"><span class="std std-ref">Arena::IImage::GetOffsetX</span></a>, <a class="reference internal" href="#class_arena_1_1_i_image_1acd698dc7982789923b2108d45e15f763"><span class="std std-ref">Arena::IImage::GetOffsetY</span></a>)</li>
<li>padding (<a class="reference internal" href="#class_arena_1_1_i_image_1a1d6d6204dc0a6551a430a9f909329449"><span class="std std-ref">Arena::IImage::GetPaddingX</span></a>, <a class="reference internal" href="#class_arena_1_1_i_image_1addc607820097002984005ee665cac14a"><span class="std std-ref">Arena::IImage::GetPaddingY</span></a>)</li>
<li>pixel information (<a class="reference internal" href="#class_arena_1_1_i_image_1a9b5d04e88fa65880850d37f3be2677e8"><span class="std std-ref">Arena::IImage::GetPixelFormat</span></a>, <a class="reference internal" href="#class_arena_1_1_i_image_1a7010692204fa7f16c4962d1ddb23becd"><span class="std std-ref">Arena::IImage::GetPixelEndianness</span></a>)</li>
<li>timestamps (<a class="reference internal" href="#class_arena_1_1_i_image_1a9e07e3c344052797d20dbc5cef0e48e6"><span class="std std-ref">Arena::IImage::GetTimestamp</span></a>, <a class="reference internal" href="#class_arena_1_1_i_image_1a13cd8f5b136dc4e8ee20ec3418456951"><span class="std std-ref">Arena::IImage::GetTimestampNs</span></a>)</li>
</ul>
</p>
<p>It is important to note that images retrieved from the camera must be requeued (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1a978bd841ed2818fc717e706aac8218f6"><span class="std std-ref">Arena::IDevice::RequeueBuffer</span></a>) whereas images created using the image factory must be destroyed (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory_1a772c024ae2279e65bb80d7f8bd74aa29"><span class="std std-ref">Arena::ImageFactory::Destroy</span></a>).</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// retrieving an image, copying it, requeuing its buffer, and destroying the copy</span>
<span class="p">{</span>
    <span class="n">Arena</span><span class="o">::</span><span class="n">IImage</span><span class="o">*</span> <span class="n">pRetrievedImage</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">GetImage</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
    <span class="n">Arena</span><span class="o">::</span><span class="n">IImage</span><span class="o">*</span> <span class="n">pCopiedImage</span> <span class="o">=</span> <span class="n">Arena</span><span class="o">::</span><span class="n">ImageFactory</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetData</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetHeight</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetWidth</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetBitsPerPixel</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetImageLength</span><span class="p">(),</span> <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">GetPixelFormat</span><span class="p">());</span>
    <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">RequeueBuffer</span><span class="p">(</span><span class="n">pRetrievedImage</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">Arena</span><span class="o">::</span><span class="n">ImageFactory</span><span class="o">::</span><span class="n">Destroy</span><span class="p">(</span><span class="n">pCopiedImage</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Should be requeued if retrieved from the device</li>
<li>Must be destroyed if created by the image factory</li>
<li>Properties of images from the stream engine are lazily instantiated</li>
<li>Properties of images from the image factory may be unavailable</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a></li>
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer"><span class="std std-ref">Arena::IBuffer</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getwidth">
<h2>GetWidth<a class="headerlink" href="#getwidth" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage8GetWidthEv">
<span id="_CPPv2N5Arena6IImage8GetWidthEv"></span><span id="Arena::IImage::GetWidth"></span><span class="target" id="class_arena_1_1_i_image_1a3056d60ca22b209922bd6fdeb99e3f41"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetWidth</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage8GetWidthEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetWidth </strong> gets the width of the image in pixels. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Width of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the width is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the width is populated by the arguments.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getheight">
<h2>GetHeight<a class="headerlink" href="#getheight" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage9GetHeightEv">
<span id="_CPPv2N5Arena6IImage9GetHeightEv"></span><span id="Arena::IImage::GetHeight"></span><span class="target" id="class_arena_1_1_i_image_1aaf4a3ba162499e7d142f23f07f709b67"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetHeight</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage9GetHeightEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetHeight </strong> gets the height of the image. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Height of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the height is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the height is populated by the arguments.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getoffsetx">
<h2>GetOffsetX<a class="headerlink" href="#getoffsetx" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage10GetOffsetXEv">
<span id="_CPPv2N5Arena6IImage10GetOffsetXEv"></span><span id="Arena::IImage::GetOffsetX"></span><span class="target" id="class_arena_1_1_i_image_1a31afe0e36757029b3e1e9756b5776e25"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetOffsetX</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage10GetOffsetXEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetOffsetX </strong> gets the offset of the image along the X-axis. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Offset X of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the offset X is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the offset X is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image is created from parameters, the offset X will be set to 0, no matter its original value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getoffsety">
<h2>GetOffsetY<a class="headerlink" href="#getoffsety" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage10GetOffsetYEv">
<span id="_CPPv2N5Arena6IImage10GetOffsetYEv"></span><span id="Arena::IImage::GetOffsetY"></span><span class="target" id="class_arena_1_1_i_image_1acd698dc7982789923b2108d45e15f763"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetOffsetY</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage10GetOffsetYEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetOffsetY </strong> gets the offset of the image along the Y-axis. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Offset Y of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the offset Y is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the offset Y is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the created from parameters, the offset Y will be set to 0, no matter its original value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpaddingx">
<h2>GetPaddingX<a class="headerlink" href="#getpaddingx" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage11GetPaddingXEv">
<span id="_CPPv2N5Arena6IImage11GetPaddingXEv"></span><span id="Arena::IImage::GetPaddingX"></span><span class="target" id="class_arena_1_1_i_image_1a1d6d6204dc0a6551a430a9f909329449"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPaddingX</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage11GetPaddingXEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPaddingX </strong> gets the padding of the image along the X-axis. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Padding X of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the padding X is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the padding X is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image was created from parameters, the padding X will be set to 0, no matter its original value.</p>
<p>Padding X specifically refers to the number of bytes padding the end of each line. This number will affect the pitch/stride/step of an image.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpaddingy">
<h2>GetPaddingY<a class="headerlink" href="#getpaddingy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage11GetPaddingYEv">
<span id="_CPPv2N5Arena6IImage11GetPaddingYEv"></span><span id="Arena::IImage::GetPaddingY"></span><span class="target" id="class_arena_1_1_i_image_1addc607820097002984005ee665cac14a"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPaddingY</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage11GetPaddingYEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPaddingY </strong> gets the padding of the image along the Y-axis. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Padding Y of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the padding Y is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the padding Y is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image was created from parameters, the padding Y will be set to 0, no matter its original value.</p>
<p>Padding Y specifically refers to the number of bytes padding the end of an image. This number will not affect the pitch/stride/step of an image.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpixelformat">
<h2>GetPixelFormat<a class="headerlink" href="#getpixelformat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage14GetPixelFormatEv">
<span id="_CPPv2N5Arena6IImage14GetPixelFormatEv"></span><span id="Arena::IImage::GetPixelFormat"></span><span class="target" id="class_arena_1_1_i_image_1a9b5d04e88fa65880850d37f3be2677e8"></span>uint64_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPixelFormat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage14GetPixelFormatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPixelFormat </strong> gets the pixel format (PfncFormat) of the image, as defined by the PFNC (Pixel Format Naming Convention). Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: uint64_t</li>
<li>Represents: enum PfncFormat</li>
<li>Pixel format of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the pixel format is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the pixel format is populated by the arguments.</p>
<p>Pixel format value are determined by the PFNC (Pixel Format Naming Convention) specification. The PFNC assigns a name and number to each pixel format helping to standardize pixel formats. The number of bits per pixel can be found in each integer at bytes 5 and 6 (mask 0x00FF0000). The pixel format can be determined by the integer using the GetPixelFormatName function provided by the PFNC.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getbitsperpixel">
<h2>GetBitsPerPixel<a class="headerlink" href="#getbitsperpixel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage15GetBitsPerPixelEv">
<span id="_CPPv2N5Arena6IImage15GetBitsPerPixelEv"></span><span id="Arena::IImage::GetBitsPerPixel"></span><span class="target" id="class_arena_1_1_i_image_1a681927dfa7b496f7825897319c64adb0"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetBitsPerPixel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage15GetBitsPerPixelEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetBitsPerPixel </strong> gets the number of bits per pixel of the image from the integer value of the pixel format (PfncFormat). Internally, a public helper funciton is called (Arena::GetBitsPerPixel).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: pixels</li>
<li>Bits per pixel of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Pixel format value are determined by the PFNC (Pixel Format Naming Convention) specification. The PFNC assigns a name and number to each pixel format helping to standardize pixel formats. The number of bits per pixel can be found in each integer at bytes 5 and 6 (mask 0x00FF0000). The pixel format can be determined by the integer using the GetPixelFormatName function provided by the PFNC.</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li>Arena::GetBitsPerPixel </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpixelendianness">
<h2>GetPixelEndianness<a class="headerlink" href="#getpixelendianness" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage18GetPixelEndiannessEv">
<span id="_CPPv2N5Arena6IImage18GetPixelEndiannessEv"></span><span id="Arena::IImage::GetPixelEndianness"></span><span class="target" id="class_arena_1_1_i_image_1a7010692204fa7f16c4962d1ddb23becd"></span>int32_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPixelEndianness</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage18GetPixelEndiannessEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPixelEndianness </strong> gets the pixel endianness (Arena::EPixelEndianness) of the image. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: int32_t</li>
<li>Represents: enum Arena::EPixelEndianness</li>
<li>Endianness of the pixels of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the pixel endianness is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the pixel endianness is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image was created from parameters, the pixel endianness will be set to 0 (EPixelEndianness::PixelEndiannessUnknown), no matter its original value.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a></li>
<li>Arena::EPixelEndianness </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="gettimestamp">
<h2>GetTimestamp<a class="headerlink" href="#gettimestamp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage12GetTimestampEv">
<span id="_CPPv2N5Arena6IImage12GetTimestampEv"></span><span id="Arena::IImage::GetTimestamp"></span><span class="target" id="class_arena_1_1_i_image_1a9e07e3c344052797d20dbc5cef0e48e6"></span>uint64_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetTimestamp</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage12GetTimestampEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetTimestamp </strong> gets the timestamp of the image in nanoseconds. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: uint64_t</li>
<li>Unit: nanoseconds</li>
<li>Timestamp of the image in nanoseconds</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the timestamp is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the timestamp is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image was created from parameters, the timestamp will be set to 0, no matter its original value.</p>
<p>This is the same as the nanosecond timestamp call (<a class="reference internal" href="#class_arena_1_1_i_image_1a13cd8f5b136dc4e8ee20ec3418456951"><span class="std std-ref">Arena::IImage::GetTimestampNs</span></a>).</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image_1a13cd8f5b136dc4e8ee20ec3418456951"><span class="std std-ref">Arena::IImage::GetTimestampNs</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="gettimestampns">
<h2>GetTimestampNs<a class="headerlink" href="#gettimestampns" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage14GetTimestampNsEv">
<span id="_CPPv2N5Arena6IImage14GetTimestampNsEv"></span><span id="Arena::IImage::GetTimestampNs"></span><span class="target" id="class_arena_1_1_i_image_1a13cd8f5b136dc4e8ee20ec3418456951"></span>uint64_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetTimestampNs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage14GetTimestampNsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetTimestampNs </strong> gets the timestamp of the image in nanoseconds. Images are self-describing, so the device does not need to be queried to get this information.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: uint64_t</li>
<li>Unit: nanoseconds</li>
<li>Timestamp of the image in nanoseconds</li>
</ul>
</dd>
</dl>
</p>
<p>Images are either retrieved from a device (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a>) or created by the image factory (<a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a>). If the image was retrieved from a device, the timestamp is populated by the acquisition engine payload leader. The device itself is not queried as this data is present in the image data. If the image was created by the image factory, the timestamp is populated by the arguments.</p>
<p>The image factory can create an image from another image (<a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a>) or from a minimal set of parameters (data, width, height, pixel format). If the image was created from parameters, the timestamp will be set to 0, no matter its original value.</p>
<p>This is the same as the general timestamp call (<a class="reference internal" href="#class_arena_1_1_i_image_1a9e07e3c344052797d20dbc5cef0e48e6"><span class="std std-ref">Arena::IImage::GetTimestamp</span></a>).</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device"><span class="std std-ref">Arena::IDevice</span></a></li>
<li><a class="reference internal" href="cpp_arena_imagefactory.html#class_arena_1_1_image_factory"><span class="std std-ref">Arena::ImageFactory</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a></li>
<li><a class="reference internal" href="#class_arena_1_1_i_image_1a9e07e3c344052797d20dbc5cef0e48e6"><span class="std std-ref">Arena::IImage::GetTimestamp</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getdata">
<h2>GetData<a class="headerlink" href="#getdata" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage7GetDataEv">
<span id="_CPPv2N5Arena6IImage7GetDataEv"></span><span id="Arena::IImage::GetData"></span><span class="target" id="class_arena_1_1_i_image_1a037ea4a7e60a80c2e759fcaa2ca722f1"></span><em class="property">const</em> uint8_t *<code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage7GetDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetData </strong> returns a pointer to the beginning of the image’s payload data. The payload may include chunk data.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: const uint8_t*</li>
<li>Pointer to the payload data</li>
</ul>
</dd>
</dl>
</p>
<p>The returned data only includes payload data, not transport layer protocol leaders, which is handled internally. The pointer can be used in conjunction with size getters (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a>) to read, process, and pass the data around. The data may include image data (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a5311fdc30b40be01c5d09aa02b4e4b3f"><span class="std std-ref">Arena::IBuffer::HasImageData</span></a>), chunk data (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a13e85d81492f826ed4b62aa3b7e52458"><span class="std std-ref">Arena::IBuffer::HasChunkData</span></a>), or both.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a></li>
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a5311fdc30b40be01c5d09aa02b4e4b3f"><span class="std std-ref">Arena::IBuffer::HasImageData</span></a></li>
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a13e85d81492f826ed4b62aa3b7e52458"><span class="std std-ref">Arena::IBuffer::HasChunkData</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getsizefilled">
<h2>GetSizeFilled<a class="headerlink" href="#getsizefilled" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage13GetSizeFilledEv">
<span id="_CPPv2N5Arena6IImage13GetSizeFilledEv"></span><span id="Arena::IImage::GetSizeFilled"></span><span class="target" id="class_arena_1_1_i_image_1a436b990b9e0562ce4bb344a1709a565d"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetSizeFilled</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage13GetSizeFilledEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetSizeFilled </strong> retrieves the size of the data of a buffer, excluding transport layer protocol leaders.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: bytes</li>
<li>Size of the payload data</li>
</ul>
</dd>
</dl>
</p>
<p>The size filled is often same as the size of the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a>), but not because they are one and the same. <strong> GetSizeFilled </strong> returns the number of bytes received whereas <strong> GetSizeOfBuffer </strong> returns the size of the buffer, which can either be allocated by the user or calculated by Arena (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1af5e97a2c24ecd66ff490db3f134b4d45"><span class="std std-ref">Arena::IDevice::GetNodeMap</span></a>, ‘PayloadSize’).</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a></li>
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1af5e97a2c24ecd66ff490db3f134b4d45"><span class="std std-ref">Arena::IDevice::GetNodeMap</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpayloadsize">
<h2>GetPayloadSize<a class="headerlink" href="#getpayloadsize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage14GetPayloadSizeEv">
<span id="_CPPv2N5Arena6IImage14GetPayloadSizeEv"></span><span id="Arena::IImage::GetPayloadSize"></span><span class="target" id="class_arena_1_1_i_image_1a92e61681e0ca1da7b31e628ff96079b4"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPayloadSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage14GetPayloadSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPayloadSize </strong> retrieves the intended size of the payload. This is similar to the retrieved payload size (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a>), but different in that missed data is included. This returns the same as the SFNC feature by the same name (‘PayloadSize’).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: bytes</li>
<li>Size of the intended payload</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behavior if buffer requeued</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getsizeofbuffer">
<h2>GetSizeOfBuffer<a class="headerlink" href="#getsizeofbuffer" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage15GetSizeOfBufferEv">
<span id="_CPPv2N5Arena6IImage15GetSizeOfBufferEv"></span><span id="Arena::IImage::GetSizeOfBuffer"></span><span class="target" id="class_arena_1_1_i_image_1a27db739ca8c0c55d948ef33ab943bf4d"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetSizeOfBuffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage15GetSizeOfBufferEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetSizeOfBuffer </strong> retrieves the size of the buffer.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Unit: bytes</li>
<li>Size of the buffer</li>
</ul>
</dd>
</dl>
</p>
<p>The size filled is often same as the size of the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a>), but not because they are one and the same. <strong> GetSizeFilled </strong> returns the number of bytes received whereas <strong> GetSizeOfBuffer </strong> returns the size of the buffer, which can either be allocated by the user or calculated by Arena (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1af5e97a2c24ecd66ff490db3f134b4d45"><span class="std std-ref">Arena::IDevice::GetNodeMap</span></a>, ‘PayloadSize’).</p>
<p>The payload size is calculated at the beginning of the stream and cannot be recalculated until the stream has stopped. Because of this, features that can affect payload size (‘Width’, ‘Height’, ‘PixelFormat’) become unwritable when the stream has started.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a></li>
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1af5e97a2c24ecd66ff490db3f134b4d45"><span class="std std-ref">Arena::IDevice::GetNodeMap</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getframeid">
<h2>GetFrameId<a class="headerlink" href="#getframeid" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage10GetFrameIdEv">
<span id="_CPPv2N5Arena6IImage10GetFrameIdEv"></span><span id="Arena::IImage::GetFrameId"></span><span class="target" id="class_arena_1_1_i_image_1a3991b7fb7402c00c3c59dca8cd1df37b"></span>uint64_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetFrameId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage10GetFrameIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetFrameId </strong> gets the frame ID, a sequential identifier for buffers.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: uint64_t</li>
<li>Frame ID of the image</li>
</ul>
</dd>
</dl>
</p>
<p>Frame IDs start at ‘1’ and continue until either 65535 (16-bit) or 2^64-1 (64-bit), at which point they roll over back to ‘1’. The frame ID should never be ‘0’. In order to use 64-bit frame IDs, the device must support GigE Vision 2.0. Simply enable the extended ID mode feature (‘GevGVSPExtendedIDMode’).</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="getpayloadtype">
<h2>GetPayloadType<a class="headerlink" href="#getpayloadtype" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage14GetPayloadTypeEv">
<span id="_CPPv2N5Arena6IImage14GetPayloadTypeEv"></span><span id="Arena::IImage::GetPayloadType"></span><span class="target" id="class_arena_1_1_i_image_1a86fd42b1c55d8a9a3018183f6ed554e4"></span>size_t <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">GetPayloadType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage14GetPayloadTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> GetPayloadType </strong> returns a buffer’s payload type (Arena::EBufferPayloadType), as defined in the GigE Vision specification.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: size_t</li>
<li>Represents: enum Arena::EBufferPayloadType</li>
<li>Type of payload data</li>
</ul>
</dd>
</dl>
</p>
<p>The payload type indicates how to interpret the data stored in the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a606401eb4f017a15f767bfe371197ec2"><span class="std std-ref">Arena::IBuffer::GetData</span></a>). Lucid devices may provide three ways to interpret the data:<ul class="simple">
<li>as an image (Arena::EBufferPayloadType::BufferPayloadTypeImage)</li>
<li>as an image with chunk data appended to the end (Arena::EBufferPayloadType::BufferPayloadTypeImageExtended)</li>
<li>as chunk data, which may or may not include image data as a chunk</li>
<li>(Arena::EBufferPayloadType::BufferPayloadTypeChunkData)</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a606401eb4f017a15f767bfe371197ec2"><span class="std std-ref">Arena::IBuffer::GetData</span></a></li>
<li>Arena::EBufferPayloadType </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="hasimagedata">
<h2>HasImageData<a class="headerlink" href="#hasimagedata" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage12HasImageDataEv">
<span id="_CPPv2N5Arena6IImage12HasImageDataEv"></span><span id="Arena::IImage::HasImageData"></span><span class="target" id="class_arena_1_1_i_image_1a0ea7e88f6182631fbbd06f88612ae76e"></span>bool <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">HasImageData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage12HasImageDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> HasImageData </strong> returns whether or not a payload can be interpreted as image data. Calling <strong> HasImageData </strong> from an image returns true.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: bool</li>
<li>True if the payload has image data</li>
<li>False if the payload has image packaged as chunk data</li>
<li>Otherwise, false</li>
</ul>
</dd>
</dl>
</p>
<p><strong> HasImageData </strong> returns true if the payload type is:<ul class="simple">
<li>Arena::EBufferPayloadType::BufferPayloadTypeImage</li>
<li>Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk</li>
</ul>
</p>
<p>It returns false if the payload type is:<ul class="simple">
<li>Arena::EBufferPayloadType::BufferPayloadTypeChunkData</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li>Arena::EBufferPayloadType </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="haschunkdata">
<h2>HasChunkData<a class="headerlink" href="#haschunkdata" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage12HasChunkDataEv">
<span id="_CPPv2N5Arena6IImage12HasChunkDataEv"></span><span id="Arena::IImage::HasChunkData"></span><span class="target" id="class_arena_1_1_i_image_1a3c12ee91970c22dea82f4b96dacc21c3"></span>bool <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">HasChunkData</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage12HasChunkDataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> HasChunkData </strong> returns whether or not a payload can be interpreted as chunk data.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: bool</li>
<li>True if the payload has chunk data</li>
<li>Otherwise, false</li>
</ul>
</dd>
</dl>
</p>
<p><strong> HasChunkData </strong> returns true if the payload type is:<ul class="simple">
<li>Arena::EBufferPayloadType::BufferPayloadTypeChunkData</li>
<li>Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk</li>
</ul>
</p>
<p>It returns false if the payload type is:<ul class="simple">
<li>Arena::EBufferPayloadType::BufferPayloadTypeImage</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li>Arena::EBufferPayloadType </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="isincomplete">
<h2>IsIncomplete<a class="headerlink" href="#isincomplete" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage12IsIncompleteEv">
<span id="_CPPv2N5Arena6IImage12IsIncompleteEv"></span><span id="Arena::IImage::IsIncomplete"></span><span class="target" id="class_arena_1_1_i_image_1a3746a731e7812019002340d99b821226"></span>bool <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">IsIncomplete</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage12IsIncompleteEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> IsIncomplete </strong> returns whether or not a buffer’s payload data is complete.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: bool</li>
<li>True if the data is incomplete</li>
<li>Otherwise, false</li>
</ul>
</dd>
</dl>
</p>
<p>Error handling may be required in the case that the data is incomplete. An incomplete image signifies that the data size (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a>) does not match the expected data size (‘PayloadSize’). This is either due to missed packets or a small buffer.</p>
<p>The number of missed packets may be discovered through the stream node map (<a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1a3684196a7ca2bec87b2828bfa831aa1e"><span class="std std-ref">Arena::IDevice::GetTLStreamNodeMap</span></a>). The missed packet count feature (‘StreamMissedPacketCount’) is a cumulative count of all missed packets, and does not necessarily reflect the number of missed packets for any given buffer.</p>
<p>A buffer may be missing data if the buffer to hold the data is too small. This happens when the size of the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a>) does not match the expected data size (‘PayloadSize’). This function will also return true when checking whether the data is larger than the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1ad22763bfe643d861edc42b15f8f1f138"><span class="std std-ref">Arena::IBuffer::DataLargerThanBuffer</span></a>).</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a35903c6e5efd95052d29d1abaa6d07c1"><span class="std std-ref">Arena::IBuffer::GetSizeFilled</span></a></li>
<li><a class="reference internal" href="cpp_arena_idevice.html#class_arena_1_1_i_device_1a3684196a7ca2bec87b2828bfa831aa1e"><span class="std std-ref">Arena::IDevice::GetTLStreamNodeMap</span></a></li>
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a></li>
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1ad22763bfe643d861edc42b15f8f1f138"><span class="std std-ref">Arena::IBuffer::DataLargerThanBuffer</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="datalargerthanbuffer">
<h2>DataLargerThanBuffer<a class="headerlink" href="#datalargerthanbuffer" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage20DataLargerThanBufferEv">
<span id="_CPPv2N5Arena6IImage20DataLargerThanBufferEv"></span><span id="Arena::IImage::DataLargerThanBuffer"></span><span class="target" id="class_arena_1_1_i_image_1af9b47d39bff9845622d9f2bee6b2f8d0"></span>bool <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">DataLargerThanBuffer</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage20DataLargerThanBufferEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> DataLargerThanBuffer </strong> returns whether or not a buffer’s payload data is too larger for the buffer.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: bool</li>
<li>True if the payload is larger than the buffer</li>
<li>Otherwise, false</li>
</ul>
</dd>
</dl>
</p>
<p>A buffer may be missing data if the buffer to hold the data is too small. This happens when the size of the buffer (<a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a>) does not match the expected data size (‘PayloadSize’). This function will also return true when checking whether the data is larger than the buffer.</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>Causes undefined behaviour if buffer requeued</li>
<li>Properties lazily instantiated if buffer retrieved from device</li>
<li>May throw GenICam::GenericException or other derived exception</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="cpp_arena_ibuffer.html#class_arena_1_1_i_buffer_1a3e8f8041360305085ba30f7ecbd7c5c2"><span class="std std-ref">Arena::IBuffer::GetSizeOfBuffer</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="verifycrc">
<h2>VerifyCRC<a class="headerlink" href="#verifycrc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImage9VerifyCRCEv">
<span id="_CPPv2N5Arena6IImage9VerifyCRCEv"></span><span id="Arena::IImage::VerifyCRC"></span><span class="target" id="class_arena_1_1_i_image_1a113889d754f0d8c0da683f34e40b8e69"></span>bool <code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">VerifyCRC</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N5Arena6IImage9VerifyCRCEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><strong> VerifyCRC </strong> calculates the CRC of an image’s data and verifies it against the CRC value sent from the device. This helps verify that no data has been changed or missed during transmission. This function calls a global helper function to calculate the CRC (Arena::CalculateCRC32).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd><ul class="simple">
<li>Type: bool</li>
<li>True if the calculated CRC value equals the one sent from the device</li>
<li>Otherwise, false</li>
</ul>
</dd>
</dl>
</p>
<p>A CRC is performed by running a set of calculations on a dataset both before and after a transmission. The two calculated values are then compared for equality. If the values are the same, then the transmission is deemed successful; if different, then something in the transmission went wrong.</p>
<p>A device can be set to send a CRC value by enabling its chunk data setting.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Enable chunk data and the CRC chunk</span>
<span class="p">{</span>
    <span class="n">GenApi</span><span class="o">::</span><span class="n">INodeMap</span><span class="o">*</span> <span class="n">pNodeMap</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">GetNodeMap</span><span class="p">();</span>
    
    <span class="n">GenApi</span><span class="o">::</span><span class="n">CBooleanPtr</span> <span class="n">pChunkModeActive</span> <span class="o">=</span> <span class="n">pNodeMap</span><span class="o">-&gt;</span><span class="n">GetNode</span><span class="p">(</span><span class="s">&quot;ChunkModeActive&quot;</span><span class="p">);</span>
    <span class="n">pChunkModeActive</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    
    <span class="n">GenApi</span><span class="o">::</span><span class="n">CEnumerationPtr</span> <span class="n">pChunkSelector</span> <span class="o">=</span> <span class="n">pNodeMap</span><span class="o">-&gt;</span><span class="n">GetNode</span><span class="p">(</span><span class="s">&quot;ChunkSelector&quot;</span><span class="p">);</span>
    <span class="n">GenApi</span><span class="o">::</span><span class="n">CEnumEntryPtr</span> <span class="n">pCRC</span> <span class="o">=</span> <span class="n">pChunkSelector</span><span class="o">-&gt;</span><span class="n">GetEntryByname</span><span class="p">(</span><span class="s">&quot;CRC&quot;</span><span class="p">);</span>
    <span class="n">pChunkSelector</span><span class="o">-&gt;</span><span class="n">SetIntValue</span><span class="p">(</span><span class="n">pCRC</span><span class="o">-&gt;</span><span class="n">GetValue</span><span class="p">());</span>
    
    <span class="n">GenApi</span><span class="o">::</span><span class="n">CBooleanPtr</span> <span class="n">pChunkEnable</span> <span class="o">=</span> <span class="n">pNodeMap</span><span class="o">-&gt;</span><span class="n">GetNode</span><span class="p">(</span><span class="s">&quot;ChunkEnable&quot;</span><span class="p">);</span>
    <span class="n">pChunkEnable</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p>The data can then be checked by verifying the CRC.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Verifying a buffer&#39;s data</span>
<span class="p">{</span>
    <span class="n">Arena</span><span class="o">::</span><span class="n">IImage</span><span class="o">*</span> <span class="n">pImage</span> <span class="o">=</span> <span class="n">pDevice</span><span class="o">-&gt;</span><span class="n">GetImage</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pImage</span><span class="o">-&gt;</span><span class="n">VerifyCRC</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// data not complete</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd><ul class="simple">
<li>May throw GenICam::GenericException or other derived exception</li>
<li>Throws if chunk data disabled or not present, or CRC chunk disabled</li>
</ul>
</dd>
<dt><strong>See</strong></dt>
<dd><ul class="simple">
<li>Arena::CalculateCRC</li>
<li><a class="reference internal" href="#class_arena_1_1_i_image"><span class="std std-ref">Arena::IImage</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id2">
<h2>~IImage<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="_CPPv3N5Arena6IImageD0Ev">
<span id="_CPPv2N5Arena6IImageD0Ev"></span><span id="Arena::IImage::~IImage"></span><span class="target" id="class_arena_1_1_i_image_1aca93dcd5b29fcc4f4342e29a6d4ab2bc"></span><code class="descclassname">Arena::<a class="reference internal" href="#_CPPv3N5Arena6IImageE" title="Arena::IImage">IImage</a><code class="descclassname">::</code></code><code class="descname">~IImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N5Arena6IImageD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A destructor </p>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cpp_arena_featurestream.html" class="btn btn-neutral float-right" title="FeatureStream" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cpp_arena_interfaceinfo.html" class="btn btn-neutral" title="InterfaceInfo" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Lucid Vision Labs, Inc.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.24.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>